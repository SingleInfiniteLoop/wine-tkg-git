diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 59db16aaf9b..f8ac5976efe 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -210,6 +210,10 @@ FUNCTION_OVERRIDES = {
 
     # VK_KHR_synchronization2
     "vkQueueSubmit2KHR" : {"dispatch" : True, "extra_param" : "pSubmits"},
+
+    # Custom functions
+    "wine_vkAcquireKeyedMutex" : {"dispatch": True},
+    "wine_vkReleaseKeyedMutex" : {"dispatch": True},
 }
 
 # functions for which a user driver entry must be generated
@@ -308,6 +312,9 @@ MANUAL_UNIX_THUNKS = {
     "vkSignalSemaphoreKHR",
     "vkWaitSemaphoresKHR",
     "vkQueueSubmit2KHR",
+    # Custom functions
+    "wine_vkAcquireKeyedMutex",
+    "wine_vkReleaseKeyedMutex",
 }
 
 # loader functions which are entirely manually implemented
@@ -3410,12 +3417,16 @@ class VkRegistry(object):
         # function call we want we set a member 'required' to True.
         tree = ET.parse(reg_filename)
         root = tree.getroot()
+
+        tree_custom = ET.parse("vk_custom.xml")
+        root_custom = tree_custom.getroot()
+
         self._parse_enums(root)
         self._parse_types(root)
-        self._parse_commands(root)
+        self._parse_commands(root, root_custom)
 
         # Pull in any required types and functions.
-        self._parse_features(root)
+        self._parse_features(root, root_custom)
         self._parse_extensions(root)
 
         for enum in self.enums.values():
@@ -3508,10 +3519,10 @@ class VkRegistry(object):
             if not handle.object_type:
                 LOGGER.warning("No object type found for {}".format(handle.name))
 
-    def _parse_commands(self, root):
+    def _parse_commands(self, root, root_custom):
         """ Parse command section containing the Vulkan function calls. """
         funcs = {}
-        commands = root.findall("./commands/")
+        commands = root.findall("./commands/") + root_custom.findall("./commands/")
 
         # As of Vulkan 1.1, various extensions got promoted to Core.
         # The old commands (e.g. KHR) are available for backwards compatibility
@@ -3527,6 +3538,7 @@ class VkRegistry(object):
                 continue
 
             func = VkFunction.from_xml(command, self.types)
+
             if func:
                 funcs[func.name] = func
 
@@ -3778,10 +3790,10 @@ class VkRegistry(object):
         # Sort in alphabetical order.
         self.extensions = sorted(extensions, key=lambda ext: ext["name"])
 
-    def _parse_features(self, root):
+    def _parse_features(self, root, root_custom):
         """ Parse the feature section, which describes Core commands and types needed. """
 
-        for feature in root.findall("./feature"):
+        for feature in (root.findall("./feature") + root_custom.findall("./feature")):
             if not api_is_vulkan(feature):
                 continue
             feature_name = feature.attrib["name"]
diff --git a/dlls/winevulkan/vk_custom.xml b/dlls/winevulkan/vk_custom.xml
new file mode 100644
index 00000000000..a9fd68548c4
--- /dev/null
+++ b/dlls/winevulkan/vk_custom.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<registry>
+    <commands>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_UNKNOWN">
+            <proto><type>VkResult</type> <name>wine_vkAcquireKeyedMutex</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>uint64_t</type> <name>key</name></param>
+            <param><type>uint32_t</type> <name>timeout_ms</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN">
+            <proto><type>VkResult</type> <name>wine_vkReleaseKeyedMutex</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>uint64_t</type> <name>key</name></param>
+        </command>
+    </commands>
+    <feature api="vulkan,vulkansc" name="WINE_CUSTOM" comment="Wine custom functions.">
+        <require>
+            <command name="wine_vkAcquireKeyedMutex"/>
+            <command name="wine_vkReleaseKeyedMutex"/>
+        </require>
+    </feature>
+</registry>
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index 40da11ec4b8..27cf80ee907 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -3990,6 +3990,8 @@ static void substitute_function_name(const char **name)
         *name = "vkGetSemaphoreFdKHR";
     else if (!strcmp(*name, "vkImportSemaphoreWin32HandleKHR"))
         *name = "vkImportSemaphoreFdKHR";
+    else if (!strcmp(*name, "wine_vkAcquireKeyedMutex") || !strcmp(*name, "wine_vkReleaseKeyedMutex"))
+        *name = "vkImportSemaphoreFdKHR";
 }
 
 #ifdef _WIN64
@@ -5469,3 +5471,13 @@ VkResult wine_vkQueueBindSparse(VkQueue queue_handle, uint32_t bind_info_count,
     free_conversion_context(&ctx);
     return ret;
 }
+
+VkResult wine_wine_vkAcquireKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key, uint32_t timeout_ms)
+{
+    return acquire_keyed_mutex(wine_device_from_handle(device), wine_device_memory_from_handle(memory), key, timeout_ms);
+}
+
+VkResult wine_wine_vkReleaseKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key)
+{
+    return release_keyed_mutex(wine_device_from_handle(device), wine_device_memory_from_handle(memory), key, NULL);
+}
