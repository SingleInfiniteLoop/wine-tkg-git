diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 56184118c97..507537df632 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -182,7 +182,7 @@ FUNCTION_OVERRIDES = {
     "vkSignalSemaphore" : {"dispatch" : True},
     "vkWaitSemaphores" : {"dispatch" : True},
     "vkQueueBindSparse" : {"dispatch" : True},
-    "vkQueueSubmit" : {"dispatch" : True},
+    "vkQueueSubmit" : {"dispatch" : True, "extra_param" : "pSubmits"},
     "vkQueueSubmit2" : {"dispatch" : True},
     "vkDestroySemaphore" : {"dispatch" : True},
 
@@ -347,11 +347,16 @@ STRUCT_CHAIN_CONVERSIONS = {
     "VkPhysicalDeviceImageFormatInfo2": [],
     "VkPhysicalDeviceExternalSemaphoreInfo": [],
     "VkSemaphoreCreateInfo": ["VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"],
-    "VkSubmitInfo": [],
+    "VkSubmitInfo": ["VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"],
     "VkSubmitInfo2": [],
     "VkBindSparseInfo" : [],
 }
 
+STRUCT_COPY = {
+    "VkSubmitInfo",
+    "VkSubmitInfo2",
+};
+
 # Some struct members are conditionally ignored and callers are free to leave them uninitialized.
 # We can't deduce that from XML, so we allow expressing it here.
 MEMBER_LENGTH_EXPRESSIONS = {
@@ -1473,6 +1478,9 @@ class VkVariable(object):
                 if struct.needs_conversion(conv, unwrap, Direction.OUTPUT, is_const):
                     conversions.append(StructConversionFunction(struct, Direction.OUTPUT, conv, unwrap, is_const))
 
+            if struct.name in STRUCT_COPY:
+                conversions.append(StructConversionFunction(struct, Direction.INPUT, False, unwrap, is_const, True))
+
         if self.is_static_array() or self.is_dynamic_array():
             for conv in [False, True]:
                 if self.needs_conversion(conv, unwrap, Direction.INPUT, parent_const):
@@ -1602,7 +1610,7 @@ class VkMember(VkVariable):
                         values=values, object_type=object_type, bit_width=bit_width, returnedonly=returnedonly,
                         parent=parent, selection=selection, selector=selector)
 
-    def copy(self, input, output, direction, conv, unwrap):
+    def copy(self, input, output, direction, conv, unwrap, copy):
         """ Helper method for use by conversion logic to generate a C-code statement to copy this member.
             - `conv` indicates whether the statement is in a struct alignment conversion path. """
 
@@ -1658,6 +1666,11 @@ class VkMember(VkVariable):
         elif self.is_static_array():
             bytes_count = "{0} * sizeof({1})".format(self.array_len, self.type)
             return "memcpy({0}{1}, {2}{1}, {3});\n".format(output, self.name, input, bytes_count)
+        elif self.is_dynamic_array() and copy:
+            if self.type == "void":
+                return "MEMDUP_VOID(ctx, {0}{1}, {2}{1}, {3});\n".format(output, self.name, input, self.get_dyn_array_len(input, conv))
+            else:
+                return "MEMDUP(ctx, {0}{1}, {2}{1}, {3});\n".format(output, self.name, input, self.get_dyn_array_len(input, conv))
         elif conv and direction == Direction.OUTPUT and self.is_pointer():
             return "{0}{1} = PtrToUlong({2}{1});\n".format(output, self.name, input)
         elif conv and direction == Direction.INPUT and self.is_pointer():
@@ -2381,17 +2394,21 @@ class VkStruct(Sequence):
 
 
 class StructConversionFunction(object):
-    def __init__(self, struct, direction, conv, unwrap, const):
+    def __init__(self, struct, direction, conv, unwrap, const, copy=False):
         self.direction = direction
         self.operand = struct
         self.type = struct.name
         self.conv = conv
         self.unwrap = unwrap
         self.const = const
+        self.copy = copy
 
-        name = "convert_{0}_".format(self.type)
-        win_type = "win32" if self.conv else "win64"
-        name += convert_suffix(direction, win_type, unwrap, struct.is_wrapped())
+        if copy:
+            name = "copy_{0}".format(self.type)
+        else:
+            name = "convert_{0}_".format(self.type)
+            win_type = "win32" if self.conv else "win64"
+            name += convert_suffix(direction, win_type, unwrap, struct.is_wrapped())
         self.name = name
 
     def __eq__(self, other):
@@ -2423,7 +2440,7 @@ class StructConversionFunction(object):
 
         body = ""
 
-        if not self.conv:
+        if not self.conv and not self.copy:
             body += "#ifdef _WIN64\n"
 
         needs_alloc = self.direction != Direction.OUTPUT and self.operand.needs_alloc(self.conv, self.unwrap)
@@ -2433,8 +2450,11 @@ class StructConversionFunction(object):
         if self.direction == Direction.OUTPUT and self.const:
             win_type = "const " + win_type
 
-        if self.conv:
+        if self.copy:
+            body += "void {0}(".format(self.name)
+        else:
             body += "static inline void {0}(".format(self.name)
+        if self.conv:
 
             if self.direction == Direction.OUTPUT:
                 params = ["const {0} *in".format(self.type), "{0} *out".format(win_type)]
@@ -2451,8 +2471,6 @@ class StructConversionFunction(object):
             body += ")\n"
 
         else:
-            body += "static inline void {0}(".format(self.name)
-
             params = ["const {0} *in".format(self.type), "{0} *out".format(self.type)]
 
             # Generate parameter list
@@ -2492,7 +2510,7 @@ class StructConversionFunction(object):
                 body += " || ".join("selector == {}".format(s) for s in m.selection)
                 body += ")\n    "
 
-            body += "    " + m.copy("in->", "out->", self.direction, self.conv, self.unwrap)
+            body += "    " + m.copy("in->", "out->", self.direction, self.conv, self.unwrap, self.copy)
 
         if needs_extensions:
             if self.conv and self.direction == Direction.INPUT:
@@ -2551,7 +2569,7 @@ class StructConversionFunction(object):
                     if m.name == "pNext":
                         copy_body += ident + "out_ext->pNext = NULL;\n"
                         continue
-                    copy_body += ident + m.copy("in_ext->", "out_ext->", self.direction, self.conv, Unwrap.HOST)
+                    copy_body += ident + m.copy("in_ext->", "out_ext->", self.direction, self.conv, Unwrap.HOST, self.copy)
 
                 # Generate the definition of "in_ext" if we need it
                 if "in_ext->" in copy_body:
@@ -2586,7 +2604,7 @@ class StructConversionFunction(object):
             body += "        FIXME(\"Unexpected pNext\\n\");\n"
 
         body += "}\n"
-        if not self.conv:
+        if not self.conv and not self.copy:
             body += "#endif /* _WIN64 */\n"
         body += "\n"
 
diff --git a/dlls/winevulkan/vulkan.c b/dlls/winevulkan/vulkan.c
index ed8f0bfe537..689e09e8cf6 100644
--- a/dlls/winevulkan/vulkan.c
+++ b/dlls/winevulkan/vulkan.c
@@ -4226,7 +4226,7 @@ VkResult vk_queue_submit_unwrap(struct wine_queue *queue, uint32_t submit_count,
     return ret;
 }
 
-VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo *submits, VkFence fence)
+VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo *submits, VkFence fence, void *submits_win_ptr)
 {
     struct wine_queue *queue = wine_queue_from_handle(queue_handle);
     unsigned int i, k;
diff --git a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
index d840e1fc33a..891fc244527 100644
--- a/dlls/winevulkan/vulkan_private.h
+++ b/dlls/winevulkan/vulkan_private.h
@@ -448,5 +448,7 @@ static inline void init_unicode_string( UNICODE_STRING *str, const WCHAR *data )
 
 #define MEMDUP(ctx, dst, src, count) dst = conversion_context_alloc((ctx), sizeof(*(dst)) * (count)); \
     memcpy((void *)(dst), (src), sizeof(*(dst)) * (count));
+#define MEMDUP_VOID(ctx, dst, src, size) dst = conversion_context_alloc((ctx), size); \
+    memcpy((void *)(dst), (src), size);
 
 #endif /* __WINE_VULKAN_PRIVATE_H */
