diff --git a/dlls/mf/sar.c b/dlls/mf/sar.c
index 19e4eeda6b7..583226b9b7a 100644
--- a/dlls/mf/sar.c
+++ b/dlls/mf/sar.c
@@ -16,6 +16,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <float.h>
+
 #define COBJMACROS
 
 #include "mfapi.h"
@@ -81,6 +83,7 @@ struct audio_renderer
     IMFSimpleAudioVolume IMFSimpleAudioVolume_iface;
     IMFAudioStreamVolume IMFAudioStreamVolume_iface;
     IMFAudioPolicy IMFAudioPolicy_iface;
+    IMFRateSupport IMFRateSupport_iface;
     IMFAsyncCallback render_callback;
     LONG refcount;
     IMFMediaEventQueue *event_queue;
@@ -165,6 +168,11 @@ static struct audio_renderer *impl_from_IMFAudioPolicy(IMFAudioPolicy *iface)
     return CONTAINING_RECORD(iface, struct audio_renderer, IMFAudioPolicy_iface);
 }
 
+static struct audio_renderer *impl_from_IMFRateSupport(IMFRateSupport *iface)
+{
+    return CONTAINING_RECORD(iface, struct audio_renderer, IMFRateSupport_iface);
+}
+
 static struct audio_renderer *impl_from_IMFStreamSink(IMFStreamSink *iface)
 {
     return CONTAINING_RECORD(iface, struct audio_renderer, IMFStreamSink_iface);
@@ -801,6 +809,10 @@ static HRESULT WINAPI audio_renderer_get_service_GetService(IMFGetService *iface
     {
         *obj = &renderer->IMFAudioPolicy_iface;
     }
+    else if (IsEqualGUID(service, &MF_RATE_CONTROL_SERVICE) && IsEqualIID(riid, &IID_IMFRateSupport))
+    {
+        *obj = &renderer->IMFRateSupport_iface;
+    }
     else
         FIXME("Unsupported service %s, interface %s.\n", debugstr_guid(service), debugstr_guid(riid));
 
@@ -1145,6 +1157,105 @@ static const IMFAudioPolicyVtbl audio_renderer_policy_vtbl =
     audio_renderer_policy_GetIconPath,
 };
 
+static HRESULT WINAPI audio_renderer_rate_support_QueryInterface(IMFRateSupport *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFRateSupport) || IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFRateSupport_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI audio_renderer_rate_support_AddRef(IMFRateSupport *iface)
+{
+    struct audio_renderer *renderer = impl_from_IMFRateSupport(iface);
+    return IMFMediaSink_AddRef(&renderer->IMFMediaSink_iface);
+}
+
+static ULONG WINAPI audio_renderer_rate_support_Release(IMFRateSupport *iface)
+{
+    struct audio_renderer *renderer = impl_from_IMFRateSupport(iface);
+    return IMFMediaSink_Release(&renderer->IMFMediaSink_iface);
+}
+
+static HRESULT WINAPI audio_renderer_rate_support_GetFastestRate(IMFRateSupport *iface, MFRATE_DIRECTION direction, 
+                                                                 BOOL thin, float *rate)
+{
+    struct audio_renderer *renderer = impl_from_IMFRateSupport(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("%p, %d, %d, %p.\n", iface, direction, thin, rate);
+
+    EnterCriticalSection(&renderer->cs);
+    if (renderer->flags & SAR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (!rate)
+        hr = E_POINTER;
+    else
+        *rate = direction == MFRATE_FORWARD ? FLT_MAX : -FLT_MAX;
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
+}
+
+static HRESULT WINAPI audio_renderer_rate_support_GetSlowestRate(IMFRateSupport *iface, MFRATE_DIRECTION direction,
+                                                                 BOOL thin, float *rate)
+{
+    struct audio_renderer *renderer = impl_from_IMFRateSupport(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("%p, %d, %d, %p.\n", iface, direction, thin, rate);
+
+    EnterCriticalSection(&renderer->cs);
+    if (renderer->flags & SAR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else if (!rate)
+        hr = E_POINTER;
+    else
+        *rate = 0.0f;
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
+}
+
+static HRESULT WINAPI audio_renderer_rate_support_IsRateSupported(IMFRateSupport *iface, BOOL thin, float rate,
+                                                                  float *nearest_rate)
+{
+    struct audio_renderer *renderer = impl_from_IMFRateSupport(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("%p, %d, %f, %p.\n", iface, thin, rate, nearest_rate);
+
+    EnterCriticalSection(&renderer->cs);
+    if (renderer->flags & SAR_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else
+    {
+        if (nearest_rate)
+            *nearest_rate = rate;
+    }
+    LeaveCriticalSection(&renderer->cs);
+
+    return hr;
+}
+
+static const IMFRateSupportVtbl audio_renderer_rate_support_vtbl =
+{
+    audio_renderer_rate_support_QueryInterface,
+    audio_renderer_rate_support_AddRef,
+    audio_renderer_rate_support_Release,
+    audio_renderer_rate_support_GetFastestRate,
+    audio_renderer_rate_support_GetSlowestRate,
+    audio_renderer_rate_support_IsRateSupported,
+};
+
 static HRESULT sar_create_mmdevice(IMFAttributes *attributes, struct audio_renderer *renderer)
 {
     WCHAR *endpoint;
@@ -1931,6 +2042,7 @@ static HRESULT sar_create_object(IMFAttributes *attributes, void *user_context,
     renderer->IMFSimpleAudioVolume_iface.lpVtbl = &audio_renderer_simple_volume_vtbl;
     renderer->IMFAudioStreamVolume_iface.lpVtbl = &audio_renderer_stream_volume_vtbl;
     renderer->IMFAudioPolicy_iface.lpVtbl = &audio_renderer_policy_vtbl;
+    renderer->IMFRateSupport_iface.lpVtbl = &audio_renderer_rate_support_vtbl;
     renderer->render_callback.lpVtbl = &audio_renderer_render_callback_vtbl;
     renderer->refcount = 1;
     InitializeCriticalSection(&renderer->cs);
